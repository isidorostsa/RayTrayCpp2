#pragma once

#include "hittable.h"

sphere: type = {
    this: hittable;
    using hittable::hit_record;

    private center: point3;
    private radious: double;

    get_center: (this) center;
    get_radious: (this) radious;

    operator=: (out this, c: point3, r: double) = {
        hittable = _;
        center = c;
        radious = r;
    }

    hit: (
        final this,
        r: ray,
        ray_interval: interval
    ) -> std::optional<hit_record> == {
        orig_to_ct := center - r.origin();

        a := r.direction().length_squared();
        h := dot(r.direction(), orig_to_ct);
        c := orig_to_ct.length_squared() - radious*radious;

        // such that t = (h +/- sqrt(h^2 - ac)) / a
        // implies that the point p = ray.at(t) is on the 
        // surface of the sphere with the given center and 
        // radius. If p is a single point then it is on the 
        // border of the sphere from our pov. If it is 2 points
        // then the ray is going through the sphere and one of 
        // the points is the entry and the other the exit.

        // We only have one sphere, in front of the camera,
        // so t is always non-negative. Thus, the (-) solution
        // is a smaller number and represents the entry point.

        discriminant := h*h - a*c;
        discriminant_sqrt := std::sqrt(discriminant);

        // Find closest root that is also in the given range
        root:= :() -> std::optional<double> == {
            /*
            Design choice: In the begining this was done without
            a directly in this function without a lambda. This caused 
            the "candidate_root" variable to escape this part of the
            function. But the only reason we are using an optional instead
            of just keeping a root variable and a boolean to denote if it
            is within the correct range, is to *make invalid state unrepresentable*,
            e.g. preventing a case where the root would be accessed without checking
            if it is within the range. All of that lead to the design choice that 
            the part of the code that deals with roots should not expose any variables,
            and thus an extra function was used instead. It is a lambda only for 
            simplicity. If all this is not optimized away this approach is 
            very bad though.
            */
            candidate_root := (h - discriminant_sqrt) / a;
            if ray_interval.surrounds(candidate_root) {
                return candidate_root;
            } else {
                candidate_root = (h + discriminant_sqrt) / a;
                if ray_interval.surrounds(candidate_root) {
                    return candidate_root;
                }
            }
            return std::nullopt;
        }();
         
        /*
        Design choice: making root inaccessible if found_root is false
        */

        return root.transform(
            :(root_val: double) -> hit_record = {
                record := hit_record();

                record.contact_point = r.at(root_val);
                record.reflective_normal = (record.contact_point - center) / radious;
                record.dist_to_point = root_val;
                record.hit_front_face = (dot(r.direction(), record.reflective_normal) < 0);

                if !record.hit_front_face {
                    record.reflective_normal *= -1;
                }

                return record;
            }
        );
    }

}