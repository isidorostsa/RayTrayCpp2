#include "defines.h"

#include "sphere.h"
#include "hittable_list.h"
#include "optional_extensions.h"
#include "camera.h"

ray_color: (r: ray, world: hittable) -> color == {
    // Monadic methods
    background_color:= :() -> color == {
        a := 0.5*(r.direction().unit_vector().y()$ + 1.0);

        white: color == (1.0, 1.0, 1.0);
        blue_ish: color == (0.5, 0.7, 1.0);

        return (1.0-a)*white + a*blue_ish;
    };

    surface_color:== :(h: hittable::hit_record) -> color == {
        return 0.5 * (h.reflective_normal + color(1, 1, 1));
    };

    return world.hit(r, interval(0, infinity)).
        transform(surface_color).
        value_else(background_color); // Used thanks to UFCS

    // Conventional checking the optional way

    // if (record) { // We draw the sphere
    //     normalize_color := color(1, 1, 1);
    //     return 0.5*(record.value().norm + normalize_color);
    // } else {      // We draw the background 
    //     unit_dir :=  r.direction().unit_vector();
    //     a := 0.5*(unit_dir.y() + 1.0);

    //     white := color(1.0, 1.0, 1.0);
    //     blue_ish := color(0.5, 0.7, 1.0);

    //     return (1.0-a)*white + a*blue_ish;
    // }
}

main: (args) -> int
= {
    cam: camera == (
        16.0/9.0, // aspect_ratio
        1200, // image_width
        1.0, // focal_length
        vec3(0, 0, 0), // camera_center
        2.0 // viewport_height 
    );

    world: hittable_list = ();

    _ = world.add(make_shared<sphere>(point3(0,-100.5,-1), 100));
    _ = world.add(make_shared<sphere>(point3(0,0,-1), 0.5));

    output_file: std::ofstream = ();
    output_file.open("image.ppm");

    start_time := std::chrono::system_clock::now();
    cam.render(world, output_file);
    duration := std::chrono::system_clock::now() - start_time;
    output_file.close();

    ms: std::chrono::milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(duration);
    std::clog << "\rFinished, total time: " << ms << std::endl;

    // avg_time_per_pixel := duration / (image_height*image_height);
    // std::clog << "\rFinished, average time per pixel: " << avg_time_per_pixel << std::endl;
}
